---
layout: post
title: Webpack小结
category: 学习
---

### 为了跟上前端技术那BalaBalaBala更新的脚步，昨天晚上就像打了鸡血一样找了一系列与的webpack有关的内容来看，然后就总结了一下如何对它进行配置。

---

## 步入正题：  

npm是Node.js的模块依赖管理工具，所以需要先安装Node.js，不能翻墙的时候推荐使用([淘宝NPM镜像](https://npm.taobao.org/))。

**新建一个目录,它里面的项目结构如下:**

* app/
    * entry.js(入口文件)
    * components/(存放组件目录)
    * static/(存放静态资源)
        * css/
        * images/
* package.json
* webpack.config.js(webpack的配置文件)

使用`npm init`生成一个`package.json`([package.json介绍](https://github.com/ericdum/mujiang.info/issues/6/))。

    npm init

## 安装webpack

`--save-dev`参数表示把webpack作为项目依赖包，会在`package.json`写入相关的配置信息。   

如果需要在多个项目中使用webpack时，可以使用`-g`参数进行全局安装。

    npm install webpack --save-dev

## webpack配置


现在已经可以在`webpack.config.js`里面对它进配置  


    // webpack.config.js

    //引入Node的path模块，使用resolve方法转换成绝对路径
    var path = require('path');

    //定义一些路径
    var ROOT_PATH = path.resolve(__dirname);
    var APP_PATH = path.resolve(__dirname,'app');
    var BUILD_PATH = path.resolve(__dirname,'build');

    //webpack配置信息
    module.exports = {
        //入口文件配置
        entry:path.resolve(APP_PATH,'entry.js'),
        //输出配置
        output:{
            path:APP_PATH,
            filename:'build.js'
        }
    };


路径`path.resolve([from],to)`方法进行指向，`__dirname`表示根目录。

尽量不要使用拼接字符串方式！  
尽量不要使用拼接字符串方式！！  
尽量不要使用拼接字符串方式！！！  

重要的事情说三遍！拼接有坑，爱信不信~反正我是被坑过~ ~！！！

### entry：  

用来配置app的入口。入口可以是一个，也可以是多个，所以可以使用对象来定义多个入口文件。    

### output：  

用来配置怎么把文件输出。

`path`表示app打包后的路径。

`filename`打包后的文件名字。

**修改文件：**  

    //entry.js  

    var h1 = document.createElement('h1');
    h1.innerText = "Hello world!";
    document.body.appendChild(h1);

哈哈，没错，就是这经典的Hello world！  

    webpack -p

使用webpack来打包  

### Webpack的常用参数：  

`-p`  参数表示对打包后的文件进行压缩。  
`-w`  监听文件改动，一但发现文件改动会实时打包更新。  
`-d`  使用[SourceMaps](http://www.ruanyifeng.com/blog/2013/01/javascript_source_map.html),帮助我们调试。  
`--colors`  输出结果有颜色。  

**添加文件：**

手动新建一个`index.html`文件，再把`build.js`引进去后打开这个文件就可以看到  

# Hello World！  

但是！但是！！但是！！！这样是不是太麻烦了？  

没事，webpack中有一个`plugins`属性可以用来配置一些插件，其中就有可以自动生成`index.html`文件的`html-webpack-plugin`的插件。

    npm install html-webpack-plugin --save-dev  

把它安装到我们项目后，修改`webpack.config.js`文件  

    //webpack.config.js

    //引入自动生成html的插件
    var htmlWebpackPlugin = require('html-webpack-plugin');  


    module.exports = {
        ...
        //插件配置
        plugins:[
            //每次打包都会重新生成html文件
            new HtmlWebpackPlugin()
        ]
    }  


现在已经配置了   [html-webpack-plugin](https://www.npmjs.com/package/html-webpack-plugin) 每次使用webpack把文件打包后都会重新生成一个`index.html`文件。  

把前面生成的的`build`文件夹删除，再运行'webpack -p'后会生成：  

* build/
    * build.js
    * index.html  

### plugins:  

前面已经知道`plugins`属性是用来干嘛的。  

现在试试设置多个入口文件，使用插件把一些公用库设成全局变量不用再在每个文件都引入，顺便把他们打包成一个文件。  

    npm install react react-dom --save-dev  

安装`react`和`react-dom`  

**修改文件：**

    //webpack.config  
    ...
    var webpack = require('webpack');
    module.exports = {
        ...
        entry:{
            app:path.resolve(APP_PATH,'entry'),
            common:['react','react-dom']
        },
        ...
        resolve: {
            //设置文件格式为js或jsx可以直接require
            extensions: ['','.js', '.jsx']
        },
        plugins:[
            ...
            //定义全局变量
            new Webpack.ProvidePlugin({
                React: 'react',
                ReactDOM: 'react-dom'
            }),
            //用来提取entry里面设置的common，把里面的js合并成common.js
            new Webpack.optimize.CommonsChunkPlugin('common', 'common.js')
        ]
    }  

运行`webpack -p`，`build`目录已经变成这样：  

* build
    * build.js
    * common.js
    * index.html  

现在已经不用在js里面`require('react')`和`require('react-dom')`就可以通过`React`跟`ReactDOM`直接调用`React`框架。

### webpack-loader：  

上面已经引入了 [React](https://hulufei.gitbooks.io/react-tutorial/content/)  

它可以使用[JSX语法](http://reactjs.cn/react/docs/jsx-in-depth.html)更便捷的进行开发，但是需要使用[babel](https://babeljs.io/)，它可以把'JSX'、'ES6'等语法转换成浏览器可以识别的代码。

    npm install babel -g
    npm install babel-loader babel-preset-es2015 babel-preset-react --save-dev

需要先安装`babel`、`babel-preset-es2015`、`babel-preset-react`  

**修改文件：**  

    //webpack.config.js  
    ...
    module.exports = {
        ...
        module: {
            loaders: [{
                test: /\.(js|jsx)$/, //正则匹配.js或jsx的文件
                loader: 'babel', //使用babel-loader处理该文件
                include: APP_PATH, //指定为app目录下的文件
                query: {
                    presets: ['es2015', 'react'], //把使用ES6和JSX语法的文件转换成浏览器可以识别的JS文件
                }
            }]
        },
    }  

**添加文件：**  
在components里面新建一个`ColorCtrl.jsx`  
{% highlight javascript %}
//ColorCtrl.jsx
export default class ColorCtrl extends React.Component {
    constructor(props) {
        super(props);
        this.state = {
            sNum: 0
        };
        this.interval = setInterval(() => this.addNum(), 1000);
    }
    addNum() {
        this.setState({
            sNum: this.state.sNum + this.props.pNum,
        });
    }
    componentWillUnmount() {
        clearInterval(this.interval);
    }
    render() {
        if (this.state.sNum % 2 == 0) {
            return (
                <h1 style={{
                    color: 'red'
                }}>
                    even：{this.state.sNum}
                </h1>
            )
        } else {
            return (
                <h1 style={{
                    color: 'blue'
                }}>
                    odd:{this.state.sNum}
                </h1>
            )
        }
    }
};
{% endhighlight %}


这是一个单双数变色的组件并且把它导出。

**修改文件：**

    //entry.js
    ...  
    //引入ColorCtrl
    import Color from './components/ColorCtrl';
    var div =document.createElement('div');
    document.body.appendChild(div);
    ReactDOM.render(
        <Color pNum={1} />,
        div
    )

运行`webpack -p`，现在`JSX`和`ES6`语法编写的文件已经被转换成浏览器可以兼容的js文件了。  

在浏览器打开`index.html`已经可以看到随着单数蓝色双数红色的变换。  

**还可以使用`loader`干更多的事情：**  

`sass-loader` 可以把[sass](http://www.sasschina.com/guide/)(css预处理器)转换成css            
`node-loader`  sass-loader的依赖  

`css-loader` 可以用来读取css文件  

`style-loader` 把css当成一个模块插入到页面中  

`url-loader` 用来获取一些路径中的图片，并按设定的文件大小决定是否转成`base64`编码  
`file-loader` 是url-loader需要的依赖  

`expose-loader` 可以导出一些全局变量

**安装上述的loader：**  

    npm install sass-loader node-sass css-loader style-loader url-loader file-loader --save-dev  

**修改文件：**  

    //webpack.config.js
    ...
    module.exports = {
        ...
        module: {
            loaders: [
            ...
            {
                //从右往左处理样式文件
                test: /\.(css|scss)$/,
                loaders: ['style', 'css', 'sass'],
                include: APP_PATH,
            }, {
                //处理图片，小于20k的图片转成base64
                test: /\.(png|jpg|gif)$/,
                loader: 'url?limit=20480'
            }]
        },
    }

**添加文件：**  
在static/css里面新建一个`main.scss`

    //main.scss

    $green:green;
    body{
        background: url(../images/monkey.png) no-repeat center;
        background-color: $green;
    }

**修改文件：**  

    //entry.js
    ...
    require(../static/css/main);

使用webpack重新打包，打开`index.html`，样式已经被内联在里面了，小于20k的图片也被转成了`base64`编码。  

已凑齐三原色召唤出一只程序猿了~ ~！！！  

### webpack-dev-server  

一个小型的静态文件服务器，当代码保存后它会让浏览器自动刷新  

    npm install webpack-dev-server webpack-dev-middleware --save-dev  

**修改文件：**

    //webpack.config.js
    ...
    module.exports = {
        ...
        plugins: [
            ...
            //热模块替换
            new Webpack.HotModuleReplacementPlugin(),
        ],
        ...
        devServer: {
            hot: true, //开启HMR 热模块替换
            inline: true, //代码改动后刷新浏览器
            progress: true, //进度展示
            proxy: {  //重定向请求
                '/rest/*': {
                    target: 'http://127.0.0.1:80',
                    secure: false
                },
                '/ajax/*': {
                    target: 'http://127.0.0.1:81',
                    secure: false
                }
            }
        }
    }

运行`webpack-dev-server`后访问`http://localhost:8080`，修改文件已经会自动刷新浏览器了。

### open-browser-webpack-plugin
可以在启动webpack后自动在浏览器上打开`index`
    npm install open-browser-webpack-plugin --save-dev

**修改文件：**  

    //webpack.config.js
    ...
    //引入自动打开浏览器的插件
    var OpenBrowserPlugin = require('open-browser-webpack-plugin');
    module.exports = {
        ...
        plugins: [
            ...
            //自动打开浏览器
            new OpenBrowserPlugin({url: 'http://localhost:8080'}),
        ],
        ...
    }

现在每次运行`webpack-dev-server`都会自动在浏览器打开`http://localhost:8080`

### react-transform  
如果使用`React`进行复杂项目开发时，每次修改完代码后都需要刷新重新操作回到某个步骤的话必定很烦人。

    npm install babel-plugin-react-transform babel-preset-react-hmre react-transform-catch-errors react-transform-hmr redbox-react --save-dev

**修改文件：**  

    //webpack.config.js
    ...
    module.exports = {
        ...
        output:{
            ...
            publicPath:'/static/' //网站运行时访问的路径
        },
        plugins:[
            ...
            // new HtmlWebpackPlugin(),
            ...
            // new Webpack.HotModuleReplacementPlugin(),
            ...
        ],
        ...
        module:{
            loaders: [{
                //处理ES6跟jsx语法
                test: /\.(js|jsx)$/,
                loader: 'babel',
                include: APP_PATH,
                query: {
                    presets: ['es2015', 'react'],
                    plugins: [
                        [
                            'react-transform', {
                                transforms: [{
                                    transform: 'react-transform-hmr',
                                    imports: ['react'],
                                    locals: ['module']
                                }, {
                                    transform: 'react-transform-catch-errors',
                                    imports: ['react', 'redbox-react']
                                }]
                            }
                        ]
                    ]
                }
            },
            ...
            ]
        }

    }  

**修改文件：**

    //package.json
    "scripts": {
        "dev":"webpack-dev-server --inline --hot --content-base public"
    },

**添加文件：**  
在根目录下新建一个`public`目录，添加一个`index.html`  
引入打包后所依赖的文件  

    npm run dev

在更改`React` Components 时将会使组件局部刷新而不是全局刷新。  

### 发布配置  

一个项目通常会有一个两个配置文件，一个开发时使用一个发布的时候使用。  

复制一份`webpack.config.js`重名为`build.config.js`。  

把开发的一些配置删除


**修改文件：**

    //bulid.config.js
    ...
    module.exports = {
        output:{
            ...
            filename:'bundle.[hash].js'
        }
        ...
        plugins: [
            //每次打包都会重新生成html文件
            new HtmlWebpackPlugin(),
            ...
            //用来提取entry里面设置的common，把里面的js合并成common.js
            new Webpack.optimize.CommonsChunkPlugin('common', 'common.[hash].js'),
            //压缩js
            new Webpack.optimize.UglifyJsPlugin({
                compress: {
                    warnings: false
                }
            }),
        ],
    }

`[hash]`根据文件变化生成唯一的hash，上线时可以避免缓存

**修改文件：**  

    //package.json  
    "scripts": {
        "dev":"webpack --config bulid.config.js"
    },

运行`npm run dev`,最终项目结构如下：  

* app
    * components
        * ColorCtrl.jsx
    * static
        * css
            * main.scss
        * images
            * monkey.png
        * entry.js
* public
    * index.html
